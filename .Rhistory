x = "x",
k = "k",
z = "z",
method = "sem",
mimic="lm",             # since we use sem but mimic lm, we need to change other arguments default setting according to lm function
fixed.cell=TRUE,        # Mit sem Methode wäre FALSE default
fixed.z=TRUE,           # Mit sem Methode wäre FALSE deafult
homoscedasticity=TRUE,  # Mit sem Methode wäre FALSE deafult
test.stat = "Wald"
)
data <- generateData(N=24, hypothesis=1, small.effect = 0)
elrmod <- effectLite(
data = data,
y = "y",
x = "x",
k = "k",
z = "z",
method = "sem",
mimic="lm",             # since we use sem but mimic lm, we need to change other arguments default setting according to lm function
fixed.cell=TRUE,        # Mit sem Methode wäre FALSE default
fixed.z=TRUE,           # Mit sem Methode wäre FALSE deafult
homoscedasticity=TRUE,  # Mit sem Methode wäre FALSE deafult
test.stat = "Wald"
)
parnames <- c("adjmean0","adjmean1","adjmean2")
est_AdjMeans <- elrmod@results@est[parnames]
VCOV_AdjMeans <- elrmod@results@vcov.def[parnames,parnames]
hypothesis = "adjmean0 <  adjmean1; adjmean1 < adjmean2"
data <- generateData(N=24, hypothesis=1, small.effect = 0)
elrmod <- effectLite(
data = data,
y = "y",
x = "x",
k = "k",
z = "z",
method = "sem",
mimic="lm",             # since we use sem but mimic lm, we need to change other arguments default setting according to lm function
fixed.cell=TRUE,        # Mit sem Methode wäre FALSE default
fixed.z=TRUE,           # Mit sem Methode wäre FALSE deafult
homoscedasticity=TRUE,  # Mit sem Methode wäre FALSE deafult
test.stat = "Wald"
)
parnames <- c("adjmean0","adjmean1","adjmean2")
est_AdjMeans <- elrmod@results@est[parnames]
VCOV_AdjMeans <- elrmod@results@vcov.def[parnames,parnames]
hypothesis = "adjmean0 <  adjmean1; adjmean1 < adjmean2"
test <- bain(x = est_AdjMeans,
hypothesis = hypothesis,
n = 24,
Sigma = list(VCOV_AdjMeans),
group_parameters = 3, joint_parameters = 0)
test
data <- generateData(N=24, hypothesis=1, small.effect = 0)
elrmod <- effectLite(
data = data,
y = "y",
x = "x",
k = "k",
z = "z",
method = "sem",
mimic="lm",             # since we use sem but mimic lm, we need to change other arguments default setting according to lm function
fixed.cell=TRUE,        # Mit sem Methode wäre FALSE default
fixed.z=TRUE,           # Mit sem Methode wäre FALSE deafult
homoscedasticity=TRUE,  # Mit sem Methode wäre FALSE deafult
test.stat = "Wald"
)
parnames <- c("adjmean0","adjmean1","adjmean2")
est_AdjMeans <- elrmod@results@est[parnames]
VCOV_AdjMeans <- elrmod@results@vcov.def[parnames,parnames]
hypothesis = "adjmean0 <  adjmean1; adjmean1 < adjmean2"
test <- bain(x = est_AdjMeans,
hypothesis = hypothesis,
n = 24,
Sigma = list(VCOV_AdjMeans),
group_parameters = 3, joint_parameters = 0)
test
test
bain_preference(test, true_hypothesis = 1, cutoff = "unusual")
bain_preference <- function(bain_obj, true_hypothesis, cutoff="regular"){
# catch some errors I encountered with bain objects
if (is.null(bain_obj) || is.null(bain_obj$fit) || length(bain_obj$fit$PMPc) == 0) {
message("Warning: bain_obj is invalid, returning NA")
print(bain_obj)
return(as.numeric(NA))
}
################################################################################
# General settings
################################################################################
threshold <- 0.75
# get all PMPc´s of all hypotheses
pmpc <- as.numeric(bain_obj$fit$PMPc)
################################################################################
# Give names to hypotheses
################################################################################
if (is.null(names(bain_obj$fit$PMPc))) {
names(pmpc) <- paste0("H", seq_along(pmpc))
names(pmpc)[length(pmpc)] <- "Hc"  # last one is complement
} else {
names(pmpc) <- names(bain_obj$fit$PMPc)
}
################################################################################
# Matching the hypotheses names to their index
################################################################################
if (is.character(true_hypothesis)) { #if hypothesis is a character
# give true index index of where true_hypothesis matches the name of a PMPc
true_index <- match(true_hypothesis, names(pmpc))
if (is.na(true_index)) {
stop("true_hypothesis (character) not found in PMP names")
}
}
else if (is.numeric(true_hypothesis)) {
if (true_hypothesis %in% c(0, 1)) { #if hypothesis is numeric, which it is
# last is complement
if (true_hypothesis == 1) {
## !!!!!!!!!!!!!!! ##
# All indices except last (complement) count as "true", since bain makes
# two hypotheses out of one(!), might not be useful when generalizing!
true_index <- seq_len(length(pmpc) - 1)
} else {
# Complement is last
true_index <- length(pmpc)
}
} else {
true_index <- as.integer(true_hypothesis)
if (true_index < 1 || true_index > length(pmpc)) {
stop("true_hypothesis index out of range")
}
}
}
else { #if hypothesis is neither character nor numeric raise error
stop("true_hypothesis must be numeric (0/1 or index) or char. (name: H0)")
}
################################################################################
# Rules for decision making
################################################################################
if (cutoff == "regular") {
# select most supported
selected <- which.max(pmpc)
} else if (cutoff == "unusual") {
# select based on cutoff value
combined_pmp <- sum(pmpc[true_index]) #bain splits hypothesis
if (combined_pmp >= threshold) {
selected <- which.max(combined_pmp)
} else {
selected <- NA
}
} else {
stop("cutoff must be 'regular' or 'unusual'")
}
################################################################################
# Decision making
################################################################################
# No decision = incorrect
if (is.na(selected)) return(1)
# Correct if selected matches true_index
if (selected %in% true_index) {
return(0)  # correct decision
} else {
return(1)  # incorrect decision
}
}
test
bain_preference(test, true_hypothesis = 1, cutoff = "unusual")
bain_preference <- function(bain_obj, true_hypothesis, cutoff="regular"){
# catch some errors I encountered with bain objects
if (is.null(bain_obj) || is.null(bain_obj$fit) || length(bain_obj$fit$PMPc) == 0) {
message("Warning: bain_obj is invalid, returning NA")
print(bain_obj)
return(as.numeric(NA))
}
################################################################################
# General settings
################################################################################
threshold <- 0.75
# get all PMPc´s of all hypotheses
pmpc <- as.numeric(bain_obj$fit$PMPc)
################################################################################
# Give names to hypotheses
################################################################################
if (is.null(names(bain_obj$fit$PMPc))) {
names(pmpc) <- paste0("H", seq_along(pmpc))
names(pmpc)[length(pmpc)] <- "Hc"  # last one is complement
} else {
names(pmpc) <- names(bain_obj$fit$PMPc)
}
################################################################################
# Matching the hypotheses names to their index
################################################################################
if (is.character(true_hypothesis)) { #if hypothesis is a character
# give true index index of where true_hypothesis matches the name of a PMPc
true_index <- match(true_hypothesis, names(pmpc))
if (is.na(true_index)) {
stop("true_hypothesis (character) not found in PMP names")
}
}
else if (is.numeric(true_hypothesis)) {
if (true_hypothesis %in% c(0, 1)) { #if hypothesis is numeric, which it is
# last is complement
if (true_hypothesis == 1) {
## !!!!!!!!!!!!!!! ##
# All indices except last (complement) count as "true", since bain makes
# two hypotheses out of one(!), might not be useful when generalizing!
true_index <- seq_len(length(pmpc) - 1)
} else {
# Complement is last
true_index <- length(pmpc)
}
} else {
true_index <- as.integer(true_hypothesis)
if (true_index < 1 || true_index > length(pmpc)) {
stop("true_hypothesis index out of range")
}
}
}
else { #if hypothesis is neither character nor numeric raise error
stop("true_hypothesis must be numeric (0/1 or index) or char. (name: H0)")
}
################################################################################
# Rules for decision making
################################################################################
if (cutoff == "regular") {
# select most supported
selected <- which.max(pmpc)
} else if (cutoff == "unusual") {
# select based on cutoff value
combined_pmp <- sum(pmpc[true_index], na.rm=TRUE) #bain splits hypothesis
if (combined_pmp >= threshold) {
selected <- which.max(combined_pmp)
} else {
selected <- NA
}
} else {
stop("cutoff must be 'regular' or 'unusual'")
}
################################################################################
# Decision making
################################################################################
# No decision = incorrect
if (is.na(selected)) return(1)
# Correct if selected matches true_index
if (selected %in% true_index) {
return(0)  # correct decision
} else {
return(1)  # incorrect decision
}
}
bain_preference(test, true_hypothesis = 1, cutoff = "unusual")
###-----------------------------------------------------------------------------
# simdesign: Simulation study
###-----------------------------------------------------------------------------
library(SimDesign)
source("Master Skript.R")
###-----------------------------------------------------------------------------
# simdesign: Simulation study
###-----------------------------------------------------------------------------
library(SimDesign)
source("Master Skript.R")
###-----------------------------------------------------------------------------
# Design
###-----------------------------------------------------------------------------
Design <- createDesign(
N = c(24, 60, 120, 240, 480),
true_hypothesis = c(0, 1),
small.effect = c(0, 1),
threshold = c("regular", "unusual"),
hypothesis = "adjmean0 < adjmean1; adjmean1 < adjmean2"
)
###-----------------------------------------------------------------------------
# Generate
###-----------------------------------------------------------------------------
Generate <- function(condition, fixed_objects) {
data <- generateData(
N = condition$N,
hypothesis = condition$true_hypothesis,
small.effect = condition$small.effect
)
return(data)
}
###-----------------------------------------------------------------------------
# Analyse
###-----------------------------------------------------------------------------
Analyse <- function(condition, dat, fixed_objects) {
## NHST in ELR
elrmod <- elr_function(data = dat)
p_nhst <- p_value_decision(p_value = elrmod@results@hypotheses[1, "p-value"],
true_hypothesis = condition$true_hypothesis,
threshold = condition$threshold)
## IHT in ELR
p_iht <- p_value_decision(p_value = effectLite_iht(
constraints = condition$hypothesis,
test = "Wald",
object = elrmod)$pvalue,
true_hypothesis = condition$true_hypothesis,
threshold = condition$threshold)
# You can add more analyses here, returning a named vector:
return(c(
p_nhst = p_nhst,
p_iht = p_iht))
}
###-----------------------------------------------------------------------------
# Summarise
###-----------------------------------------------------------------------------
Summarise <- function(condition, results, fixed_objects) {
edr_nhst  <- mean(results[, "p_nhst"]  == 1, na.rm = TRUE)
edr_iht  <- mean(results[, "p_iht"]  == 1, na.rm = TRUE)
return(c(
EDR_NHST = edr_nhst,
EDR_IHT = edr_iht))
}
###-----------------------------------------------------------------------------
# Simulation
###-----------------------------------------------------------------------------
res <- runSimulation(design = Design,
replications = 5,
generate = Generate,
analyse = Analyse,
summarise = Summarise)
###-----------------------------------------------------------------------------
# simdesign: Simulation study
###-----------------------------------------------------------------------------
library(SimDesign)
source("Master Skript.R")
###-----------------------------------------------------------------------------
# Design
###-----------------------------------------------------------------------------
Design <- createDesign(
N = c(24, 60, 120, 240, 480),
true_hypothesis = c(0, 1),
small.effect = c(0, 1),
cutoff = c("regular", "unusual"),
hypothesis = "adjmean0 < adjmean1; adjmean1 < adjmean2"
)
###-----------------------------------------------------------------------------
# Generate
###-----------------------------------------------------------------------------
Generate <- function(condition, fixed_objects) {
data <- generateData(
N = condition$N,
hypothesis = condition$true_hypothesis,
small.effect = condition$small.effect
)
return(data)
}
###-----------------------------------------------------------------------------
# Analyse
###-----------------------------------------------------------------------------
Analyse <- function(condition, dat, fixed_objects) {
## NHST in ELR
elrmod <- elr_function(data = dat)
p_nhst <- p_value_decision(p_value = elrmod@results@hypotheses[1, "p-value"],
true_hypothesis = condition$true_hypothesis,
cutoff = condition$cutoff)
## IHT in ELR
p_iht <- p_value_decision(p_value = effectLite_iht(
constraints = condition$hypothesis,
test = "Wald",
object = elrmod)$pvalue,
true_hypothesis = condition$true_hypothesis,
cutoff = condition$cutoff)
# You can add more analyses here, returning a named vector:
return(c(
p_nhst = p_nhst,
p_iht = p_iht))
}
###-----------------------------------------------------------------------------
# Summarise
###-----------------------------------------------------------------------------
Summarise <- function(condition, results, fixed_objects) {
edr_nhst  <- mean(results[, "p_nhst"]  == 1, na.rm = TRUE)
edr_iht  <- mean(results[, "p_iht"]  == 1, na.rm = TRUE)
return(c(
EDR_NHST = edr_nhst,
EDR_IHT = edr_iht))
}
###-----------------------------------------------------------------------------
# Simulation
###-----------------------------------------------------------------------------
res <- runSimulation(design = Design,
replications = 5,
generate = Generate,
analyse = Analyse,
summarise = Summarise)
###-----------------------------------------------------------------------------
# simdesign: Simulation study
###-----------------------------------------------------------------------------
library(SimDesign)
source("Master Skript.R")
###-----------------------------------------------------------------------------
# Design
###-----------------------------------------------------------------------------
Design <- createDesign(
N = c(24, 60, 120, 240, 480),
true_hypothesis = c(0, 1),
small.effect = c(0, 1),
cutoff = c("regular", "unusual"),
hypothesis = "adjmean0 < adjmean1; adjmean1 < adjmean2"
)
###-----------------------------------------------------------------------------
# Generate
###-----------------------------------------------------------------------------
Generate <- function(condition, fixed_objects) {
data <- generateData(
N = condition$N,
hypothesis = condition$true_hypothesis,
small.effect = condition$small.effect
)
return(data)
}
###-----------------------------------------------------------------------------
# Analyse
###-----------------------------------------------------------------------------
Analyse <- function(condition, dat, fixed_objects) {
## NHST in ELR
elrmod <- elr_function(data = dat)
p_nhst <- p_value_decision(p_value = elrmod@results@hypotheses[1, "p-value"],
true_hypothesis = condition$true_hypothesis,
cutoff = condition$cutoff)
## IHT in ELR
p_iht <- p_value_decision(p_value = effectLite_iht(
constraints = condition$hypothesis,
test = "Wald",
object = elrmod)$pvalue,
true_hypothesis = condition$true_hypothesis,
cutoff = condition$cutoff)
# You can add more analyses here, returning a named vector:
return(c(
p_nhst = p_nhst,
p_iht = p_iht))
}
###-----------------------------------------------------------------------------
# Summarise
###-----------------------------------------------------------------------------
Summarise <- function(condition, results, fixed_objects) {
edr_nhst  <- mean(results[, "p_nhst"]  == 1, na.rm = TRUE)
edr_iht  <- mean(results[, "p_iht"]  == 1, na.rm = TRUE)
return(c(
EDR_NHST = edr_nhst,
EDR_IHT = edr_iht))
}
###-----------------------------------------------------------------------------
# Simulation
###-----------------------------------------------------------------------------
res <- runSimulation(design = Design,
replications = 5,
generate = Generate,
analyse = Analyse,
summarise = Summarise)
###-----------------------------------------------------------------------------
# simdesign: Simulation study
###-----------------------------------------------------------------------------
library(SimDesign)
source("Master Skript.R")
###-----------------------------------------------------------------------------
# Design
###-----------------------------------------------------------------------------
Design <- createDesign(
N = c(24, 60, 120, 240, 480),
true_hypothesis = c(0, 1),
small.effect = c(0, 1),
cutoff = c("regular", "unusual"),
hypothesis = "adjmean0 < adjmean1; adjmean1 < adjmean2"
)
###-----------------------------------------------------------------------------
# Generate
###-----------------------------------------------------------------------------
Generate <- function(condition, fixed_objects) {
data <- generateData(
N = condition$N,
hypothesis = condition$true_hypothesis,
small.effect = condition$small.effect
)
return(data)
}
###-----------------------------------------------------------------------------
# Analyse
###-----------------------------------------------------------------------------
Analyse <- function(condition, dat, fixed_objects) {
## NHST in ELR
elrmod <- elr_function(data = dat)
p_nhst <- p_value_decision(p_value = elrmod@results@hypotheses[1, "p-value"],
true_hypothesis = condition$true_hypothesis,
cutoff = condition$cutoff)
## IHT in ELR
p_iht <- p_value_decision(p_value = effectLite_iht(
constraints = condition$hypothesis,
test = "Wald",
object = elrmod)$pvalue,
true_hypothesis = condition$true_hypothesis,
cutoff = condition$cutoff)
# You can add more analyses here, returning a named vector:
return(c(
p_nhst = p_nhst,
p_iht = p_iht))
}
###-----------------------------------------------------------------------------
# Summarise
###-----------------------------------------------------------------------------
Summarise <- function(condition, results, fixed_objects) {
edr_nhst  <- mean(results[, "p_nhst"]  == 1, na.rm = TRUE)
edr_iht  <- mean(results[, "p_iht"]  == 1, na.rm = TRUE)
return(c(
EDR_NHST = edr_nhst,
EDR_IHT = edr_iht))
}
###-----------------------------------------------------------------------------
# Simulation
###-----------------------------------------------------------------------------
res <- runSimulation(design = Design,
replications = 5,
generate = Generate,
analyse = Analyse,
summarise = Summarise)
